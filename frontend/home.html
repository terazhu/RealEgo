<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RealEgo - Home</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <script src="/static/lang.js"></script>
    <style>
        :root {
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --bg-color: #f0f2f5;
            --sidebar-bg: #fff;
            --text-color: #333;
            --bubble-user: #007bff;
            --bubble-assistant: #fff;
            --border-color: #ddd;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; display: flex; height: 100vh; background-color: var(--bg-color); color: var(--text-color); }
        
        /* Sidebar */
        .sidebar { width: 260px; background: var(--sidebar-bg); padding: 20px; border-right: 1px solid var(--border-color); display: flex; flex-direction: column; flex-shrink: 0; }
        .sidebar h3 { margin-top: 0; margin-bottom: 20px; color: var(--primary-color); font-family: 'Cinzel', serif; font-size: 1.8rem; text-align: center; }
        .sidebar button { padding: 12px 15px; margin-bottom: 8px; background: transparent; border: none; border-radius: 8px; cursor: pointer; text-align: left; font-size: 1rem; color: #555; transition: all 0.2s; display: flex; align-items: center; gap: 10px; }
        .sidebar button i { width: 20px; text-align: center; }
        .sidebar button:hover { background: #f8f9fa; color: var(--primary-color); }
        .sidebar button.active { background: #e7f1ff; color: var(--primary-color); font-weight: 600; }
        .sidebar .spacer { flex: 1; }
        .sidebar button.logout { color: #dc3545; margin-top: auto; }
        .sidebar button.logout:hover { background: #ffebeb; color: #c82333; }

        /* Language Switcher */
        .lang-switch { position: absolute; top: 20px; right: 20px; z-index: 100; }
        .lang-switch select { padding: 5px 10px; background: white; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; font-size: 0.8rem; color: #666; outline: none; }
        .lang-switch select:focus { border-color: var(--primary-color); }

        /* Main Content */
        .content { flex: 1; display: flex; flex-direction: column; overflow: hidden; background: white; }
        .section { display: none; flex: 1; flex-direction: column; height: 100%; }
        .section.active { display: flex; }
        
        /* Status Panel */
        .status-container {
            border-bottom: 1px solid var(--border-color);
            background: #f8f9fa;
        }
        .status-toggle-bar {
            text-align: center;
            padding: 5px;
            cursor: pointer;
            color: var(--primary-color);
            font-size: 0.8rem;
            transition: background 0.2s;
        }
        .status-toggle-bar:hover {
            background: #e9ecef;
        }
        .status-panel { 
            padding: 10px 20px; 
            font-size: 0.85rem; 
            color: #666; 
            height: 100px; 
            overflow-y: auto; 
            font-family: monospace; 
            display: none;
            border-top: 1px solid #eee;
        }
        .status-panel.active { display: block; }
        .status-item { margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
        .status-item i { font-size: 0.8rem; }
        .status-item.log { color: #666; }
        .status-item.error { color: #dc3545; }

        /* Chat Layout */
        #chat { padding: 0; background: var(--bg-color); }
        .chat-header { padding: 15px 20px; background: white; border-bottom: 1px solid var(--border-color); font-weight: 600; font-size: 1.1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.02); z-index: 10; display: flex; justify-content: space-between; align-items: center; }
        .toggle-status { display: none; } /* Hide old button */
        .chat-box { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 15px; scroll-behavior: smooth; }
        
        /* Messages */
        .message { display: flex; flex-direction: column; max-width: 80%; }
        .message.user { align-self: flex-end; align-items: flex-end; }
        .message.assistant { align-self: flex-start; align-items: flex-start; }
        .bubble { padding: 12px 16px; border-radius: 18px; font-size: 1rem; line-height: 1.5; box-shadow: 0 1px 2px rgba(0,0,0,0.1); word-wrap: break-word; }
        .message.user .bubble { background: var(--bubble-user); color: white; border-bottom-right-radius: 4px; }
        .message.assistant .bubble { background: var(--bubble-assistant); color: var(--text-color); border-bottom-left-radius: 4px; border: 1px solid #e1e4e8; }
        .message.assistant .bubble.thinking { color: #888; font-style: italic; background: #f8f9fa; }
        
        /* Input Area */
        .input-area { padding: 20px; background: white; border-top: 1px solid var(--border-color); display: flex; gap: 10px; align-items: center; }
        .input-area input { flex: 1; padding: 12px 15px; border: 1px solid var(--border-color); border-radius: 24px; font-size: 1rem; outline: none; transition: border-color 0.2s; }
        .input-area input:focus { border-color: var(--primary-color); }
        .input-area button { padding: 10px 24px; background: var(--primary-color); color: white; border: none; border-radius: 24px; font-weight: 600; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 8px; }
        .input-area button:hover { background: var(--primary-hover); }

        /* Other Sections (Profile/Settings) */
        #profile, #settings { padding: 40px; overflow-y: auto; max-width: 800px; margin: 0 auto; width: 100%; box-sizing: border-box; }
        h2 { margin-top: 0; color: #333; margin-bottom: 30px; border-bottom: 2px solid #f0f2f5; padding-bottom: 10px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: #555; }
        input[type="text"], input[type="date"], input[type="number"], textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 1rem; box-sizing: border-box; transition: border-color 0.2s; }
        input:focus, textarea:focus { border-color: var(--primary-color); outline: none; }
        textarea { height: 120px; resize: vertical; }
        .btn-save { background: #28a745; color: white; padding: 12px 24px; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: background 0.2s; }
        .btn-save:hover { background: #218838; }
        hr { border: 0; height: 1px; background: #ddd; margin: 30px 0; }
        
        /* Timeline */
        .timeline-controls { padding: 20px 0; display: flex; align-items: center; border-bottom: 1px solid #eee; margin-bottom: 20px; }
        .btn-record { padding: 12px 24px; background: #dc3545; color: white; border: none; border-radius: 24px; font-size: 1rem; cursor: pointer; transition: transform 0.1s; display: flex; align-items: center; gap: 8px; }
        .btn-record:active { transform: scale(0.95); background: #c82333; }
        .btn-record.recording { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); } 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); } }
        
        .timeline-container { position: relative; padding-left: 30px; }
        .timeline-container::before { content: ''; position: absolute; left: 10px; top: 0; bottom: 0; width: 2px; background: #e9ecef; }
        .timeline-node { position: relative; margin-bottom: 30px; }
        .timeline-node::before { content: ''; position: absolute; left: -24px; top: 0; width: 10px; height: 10px; background: var(--primary-color); border-radius: 50%; border: 4px solid white; box-shadow: 0 0 0 2px var(--primary-color); }
        .timeline-title { font-weight: 600; font-size: 1.1rem; color: #333; margin-bottom: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .timeline-title:hover { color: var(--primary-color); }
        .timeline-content { color: #666; font-size: 0.95rem; line-height: 1.6; white-space: pre-wrap; display: none; margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .timeline-content.active { display: block; }
        .timeline-content.empty { color: #aaa; font-style: italic; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #bbb; }
    </style>
</head>
<body>
    <div class="lang-switch">
        <select id="lang-select" onchange="switchLang(this.value)">
            <option value="en">English</option>
            <option value="zh">中文</option>
        </select>
    </div>

    <div class="sidebar">
        <h3 data-i18n="title"><i class="fas fa-brain"></i> RealEgo</h3>
        <button onclick="showSection('chat')" id="btn-chat" class="active" data-i18n="nav_chat"><i class="fas fa-comments"></i> Chat</button>
        <button onclick="showSection('profile')" id="btn-profile" data-i18n="nav_profile"><i class="fas fa-user-clock"></i> Profile</button>
        <button onclick="showSection('memory')" id="btn-memory" data-i18n="nav_memory"><i class="fas fa-database"></i> Memory</button>
        <button onclick="showSection('settings')" id="btn-settings" data-i18n="nav_settings"><i class="fas fa-cog"></i> Settings</button>
        <div class="spacer"></div>
        <button onclick="logout()" class="logout" data-i18n="nav_logout"><i class="fas fa-sign-out-alt"></i> Logout</button>
    </div>

    <div class="content">
        <!-- Chat Section -->
        <div id="chat" class="section active">
            <!-- ... existing chat ... -->
            <div class="chat-header">
                <span data-i18n="chat_header">Chat with RealEgo</span>
            </div>
            <div class="status-container">
                <div class="status-panel active" id="status-panel">
                    <!-- Status logs go here -->
                    <div class="status-item"><i class="fas fa-info-circle"></i> <span data-i18n="status_ready">Ready.</span></div>
                </div>
                <div class="status-toggle-bar" onclick="toggleStatusPanel()">
                    <i id="status-toggle-icon" class="fas fa-chevron-up"></i>
                </div>
            </div>
            <div class="chat-box" id="chat-box">
                <!-- Messages -->
            </div>
            <div class="input-area">
                <input type="text" id="chat-input" placeholder="Type a message..." onkeypress="if(event.key==='Enter') sendMessage()" autocomplete="off" data-i18n="placeholder_message">
                <button onclick="sendMessage()" data-i18n="btn_send"><i class="fas fa-paper-plane"></i> Send</button>
            </div>
        </div>

        <!-- Profile (Timeline) Section -->
        <div id="profile" class="section">
            <h2 data-i18n="profile_header">Personal Timeline</h2>
            
            <div class="timeline-controls">
                <button id="btn-record" class="btn-record" onmousedown="startRecording()" onmouseup="stopRecording()" onmouseleave="stopRecording()" ontouchstart="startRecording()" ontouchend="stopRecording()">
                    <i class="fas fa-microphone"></i> <span id="record-text">Hold to Speak</span>
                </button>
                <div id="record-status" style="margin-left: 10px; color: #666; font-size: 0.9rem;"></div>
            </div>

            <div class="timeline-container" id="timeline-container">
                <!-- Timeline items will be injected here -->
            </div>
        </div>

        <!-- Memory Section (Old Profile Uploads + Search maybe later) -->
        <div id="memory" class="section">
             <h2 data-i18n="memory_header">Memory & Documents</h2>
             <div class="form-group">
                <label>Manual Memory Entry (Legacy)</label>
                <textarea id="family_info" placeholder="Any specific memory to add manually..."></textarea>
                <button onclick="saveProfile()" class="btn-save" style="margin-top:10px;">Save Text Memory</button>
             </div>
             
             <hr>
             <h3 data-i18n="upload_header">Upload Documents (TOS)</h3>
             <div class="form-group">
                <input type="file" id="file-upload" style="border: none; padding-left: 0;">
                <button onclick="uploadFile()" style="margin-top: 10px; padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;" data-i18n="btn_upload">Upload</button>
             </div>
        </div>

        <!-- Settings Section -->
        <div id="settings" class="section">
            <h2 data-i18n="settings_header">Settings</h2>
            <div class="form-group">
                <label data-i18n="label_history_limit">Chat History Limit (Number of messages to store/retrieve)</label>
                <input type="number" id="history_limit" value="100" min="10" max="1000">
            </div>
            <button onclick="saveSettings()" class="btn-save" data-i18n="btn_save_settings">Save Settings</button>
        </div>
    </div>

    <script>
        // Dynamically determine API URL based on current page protocol and host
        const protocol = window.location.protocol;
        const host = window.location.host;
        const API_URL = `${protocol}//${host}`; 
        
        const token = localStorage.getItem('token');

        if (!token) window.location.href = 'index.html';

        // Headers
        const headers = {
            'Authorization': `Bearer ${token}`
        };

        // Timeline Categories Definition - MOVED UP
        const TIMELINE_CATEGORIES = [
            { id: "0_birth", title_en: "0. Birth", title_zh: "0. 出生" },
            { id: "1_early_childhood", title_en: "1. Early Childhood (0-6)", title_zh: "1. 0~6岁经历" },
            { id: "2_primary_edu", title_en: "2. Primary/Secondary Edu", title_zh: "2. 中小学教育经历" },
            { id: "3_higher_edu", title_en: "3. Higher Education", title_zh: "3. 大学以后教育经历" },
            { id: "4_family", title_en: "4. Family Relations", title_zh: "4. 家庭关系" },
            { id: "5_social", title_en: "5. Social Relations", title_zh: "5. 社会关系" },
            { id: "6_work", title_en: "6. Work History", title_zh: "6. 工作情况" },
            { id: "7_locations", title_en: "7. Locations", title_zh: "7. 居住地/工作地/曾经生活地" },
            { id: "8_assets", title_en: "8. Assets", title_zh: "8. 财产情况" }
        ];
        
        let timelineData = {};

        function showSection(id) {
            document.querySelectorAll('.section').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.sidebar button').forEach(el => el.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            document.getElementById(`btn-${id}`).classList.add('active');
        }

        function logout() {
            localStorage.removeItem('token');
            window.location.href = 'index.html';
        }

        async function loadProfile() {
            try {
                const res = await fetch(`${API_URL}/users/me/profile`, { headers });
                if (res.status === 401) {
                    alert(t('alert_session_expired'));
                    logout();
                    return;
                }
                if (res.ok) {
                    const data = await res.json();
                    document.getElementById('full_name').value = data.full_name || '';
                    document.getElementById('birth_date').value = data.birth_date || '';
                    document.getElementById('location').value = data.location || '';
                    document.getElementById('family_info').value = data.family_info || '';
                    document.getElementById('history_limit').value = data.history_limit || 100;
                    
                    if (data.timeline_data) {
                        try {
                            timelineData = JSON.parse(data.timeline_data);
                        } catch(e) { console.error("Bad timeline JSON", e); }
                    }
                    renderTimeline();
                }
            } catch (e) {
                console.error(e);
            }
        }

        async function saveSettings() {
            const limit = document.getElementById('history_limit').value;
            try {
                const res = await fetch(`${API_URL}/users/me/profile`, {
                    method: 'PUT',
                    headers: { ...headers, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ history_limit: parseInt(limit) })
                });
                if (res.ok) alert(t('alert_settings_saved'));
                else alert(t('alert_settings_saved'));
            } catch (e) {
                console.error(e);
            }
        }

        async function saveProfile() {
            const data = {
                full_name: document.getElementById('full_name').value,
                birth_date: document.getElementById('birth_date').value || null,
                location: document.getElementById('location').value,
                family_info: document.getElementById('family_info').value
            };
            try {
                const res = await fetch(`${API_URL}/users/me/profile`, {
                    method: 'PUT',
                    headers: { ...headers, 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (res.ok) alert(t('alert_profile_saved'));
                else alert(t('alert_profile_saved')); // Actually this is error but keep simple for now or use generic fail
            } catch (e) {
                console.error(e);
            }
        }

        function toggleStatusPanel() {
            const panel = document.getElementById('status-panel');
            const icon = document.getElementById('status-toggle-icon');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                icon.className = 'fas fa-chevron-up';
            } else {
                icon.className = 'fas fa-chevron-down';
            }
        }

        function addStatusLog(text, type = 'log') {
            const panel = document.getElementById('status-panel');
            const div = document.createElement('div');
            div.className = `status-item ${type}`;
            let icon = 'info-circle';
            if (type === 'error') icon = 'exclamation-circle';
            if (text.includes('Loading')) icon = 'spinner fa-spin';
            if (text.includes('Searching')) icon = 'search';
            if (text.includes('Found')) icon = 'check-circle';
            if (text.includes('LLM')) icon = 'robot';
            if (text.includes('Queueing')) icon = 'clock';
            
            div.innerHTML = `<i class="fas fa-${icon}"></i> ${text}`;
            panel.appendChild(div);
            
            // Keep only last 10
            while (panel.children.length > 10) {
                panel.removeChild(panel.firstChild);
            }
            panel.scrollTop = panel.scrollHeight;
        }

        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value;
            if (!message) return;

            addMessage(message, 'user');
            input.value = '';

            // Show loading indicator
            const loadingId = addLoadingMessage();
            addStatusLog(t('log_sending'), 'log');

            try {
                const response = await fetch(`${API_URL}/chat/`, {
                    method: 'POST',
                    headers: { ...headers, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message })
                });

                if (response.status === 401) {
                    alert(t('alert_session_expired'));
                    logout();
                    return;
                }

                // Handle Streaming Response
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                
                // Remove loading indicator once we start receiving data or finish
                // Actually, for stream, we might want to keep it until the first real response chunk?
                // Let's remove it when we get the first "response" type chunk or at end.
                // For simplicity, let's remove it when stream ends or we process a response chunk.
                let loadingRemoved = false;
                let currentStreamMsgId = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep incomplete line

                    for (const line of lines) {
                        if (!line.trim()) continue;
                        try {
                            const data = JSON.parse(line);
                            if (data.type === 'log') {
                                // Translate log content if possible, but logs are dynamic.
                                // We can use heuristic mapping or just pass through.
                                // For better UX, we can try to match known keys.
                                let logText = data.content;
                                if (logText === 'Loading user profile...') logText = t('log_loading_profile');
                                if (logText === 'Profile loaded.') logText = t('log_profile_loaded');
                                if (logText === 'Searching relevant memories...') logText = t('log_searching_memories');
                                if (logText.includes('Found') && logText.includes('relevant memories')) {
                                    const match = logText.match(/Found (\d+) relevant memories/);
                                    if (match) logText = t('log_found_memories', { n: match[1] });
                                }
                                if (logText === 'Constructing prompt and waiting for LLM...') logText = t('log_waiting_llm');
                                if (logText === 'LLM response received.') logText = t('log_llm_received');
                                if (logText === 'Queueing background memory storage...') logText = t('log_queueing_storage');
                                if (logText === 'All tasks queued. Done.') logText = t('log_tasks_queued');
                                
                                addStatusLog(logText, 'log');
                            } else if (data.type === 'response_chunk') {
                                if (!loadingRemoved) {
                                    removeMessage(loadingId);
                                    loadingRemoved = true;
                                    // Create a new message bubble for streaming content
                                    currentStreamMsgId = 'msg-' + Date.now();
                                    addMessage("", 'assistant', currentStreamMsgId);
                                }
                                appendToMessage(currentStreamMsgId, data.content);
                            } else if (data.type === 'response') {
                                // Backward compatibility or final full response if needed (but we stream chunks now)
                                // If we rely on chunks, we might ignore this or just ensure it matches.
                                // Current backend implementation sends chunks then full text in DB, but doesn't send "response" type anymore in stream loop.
                                // Wait, the backend logic I wrote sends chunks loop, then "LLM response complete" log. 
                                // It does NOT send "response" type with full content anymore in the loop I modified.
                                if (!loadingRemoved) {
                                    removeMessage(loadingId);
                                    loadingRemoved = true;
                                    addMessage(data.content, 'assistant');
                                }
                            } else if (data.type === 'error') {
                                addStatusLog(data.content, 'error');
                            }
                        } catch (e) {
                            console.error("Error parsing stream line", e);
                        }
                    }
                }
                
                if (!loadingRemoved) removeMessage(loadingId);

            } catch (e) {
                removeMessage(loadingId);
                addMessage(t('error_server'), 'assistant');
                addStatusLog(t('error_server') + ': ' + e.message, 'error');
            }
        }

        function addLoadingMessage() {
            const box = document.getElementById('chat-box');
            const div = document.createElement('div');
            const id = 'loading-' + Date.now();
            div.id = id;
            div.className = `message assistant`;
            div.innerHTML = `<span class="bubble thinking" data-i18n="thinking">${t('thinking')}</span>`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
            return id;
        }

        function removeMessage(id) {
            const el = document.getElementById(id);
            if (el) el.remove();
        }

        function addMessage(text, role, specificId = null) {
            const box = document.getElementById('chat-box');
            const div = document.createElement('div');
            if (specificId) div.id = specificId;
            div.className = `message ${role}`;
            div.innerHTML = `<span class="bubble">${text}</span>`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        function appendToMessage(id, text) {
            const msgDiv = document.getElementById(id);
            if (msgDiv) {
                const bubble = msgDiv.querySelector('.bubble');
                if (bubble) {
                    bubble.innerText += text;
                    // Auto scroll
                    const box = document.getElementById('chat-box');
                    box.scrollTop = box.scrollHeight;
                }
            }
        }

        function uploadFile() {
            const fileInput = document.getElementById('file-upload');
            if (fileInput.files.length === 0) return;
            
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);

            try {
                fetch(`${API_URL}/upload/`, {
                    method: 'POST',
                    headers: headers, // Do NOT set Content-Type, browser sets it for FormData
                    body: formData
                })
                .then(res => {
                    if (res.ok) {
                        return res.json().then(data => {
                            alert(t('alert_upload_success', { filename: data.filename }));
                        });
                    } else {
                        alert(t('alert_upload_fail'));
                    }
                })
                .catch(e => console.error(e));
            } catch (e) {
                console.error(e);
            }
        }

        // Recording Logic
        let mediaRecorder;
        let audioChunks = [];

        async function startRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert("Audio recording not supported or permission denied.");
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };
                mediaRecorder.onstop = sendAudio;
                mediaRecorder.start();
                
                document.getElementById('btn-record').classList.add('recording');
                document.getElementById('record-text').innerText = "Recording...";
            } catch (e) {
                console.error(e);
                alert("Microphone access denied.");
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                document.getElementById('btn-record').classList.remove('recording');
                document.getElementById('record-text').innerText = "Processing...";
            }
        }

        async function sendAudio() {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' }); // Chrome/Firefox usually webm
            // Or 'audio/mp4' for Safari if needed, but Whisper handles webm fine.
            
            // Note: We need to ensure the backend receives a valid file format.
            // Let's wrap it in a File object.
            const file = new File([audioBlob], "voice_profile.webm", { type: 'audio/webm' });
            
            const formData = new FormData();
            formData.append('file', file);
            
            document.getElementById('record-status').innerText = "Uploading & Analyzing...";
            
            try {
                const res = await fetch(`${API_URL}/users/me/profile/voice`, {
                    method: 'POST',
                    headers: headers,
                    body: formData
                });
                
                if (res.ok) {
                    const profile = await res.json();
                    document.getElementById('record-status').innerText = "Done!";
                    setTimeout(() => document.getElementById('record-status').innerText = "", 3000);
                    
                    // Reload timeline
                    if (profile.timeline_data) {
                        try {
                            timelineData = JSON.parse(profile.timeline_data);
                        } catch(e) { timelineData = {}; }
                        renderTimeline();
                    }
                } else {
                    const err = await res.json();
                    alert("Error: " + err.detail);
                    document.getElementById('record-status').innerText = "Error.";
                }
            } catch (e) {
                console.error(e);
                document.getElementById('record-status').innerText = "Network Error.";
            }
        }

        function renderTimeline() {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';
            
            TIMELINE_CATEGORIES.forEach(cat => {
                const title = currentLang === 'zh' ? cat.title_zh : cat.title_en;
                let content = timelineData[cat.id] || "";
                if (typeof content === 'object') content = JSON.stringify(content, null, 2);
                
                const isEmpty = !content || content.trim() === "";
                
                const node = document.createElement('div');
                node.className = 'timeline-node';
                node.innerHTML = `
                    <div class="timeline-title" onclick="toggleTimelineItem(this)">
                        ${title}
                        <i class="fas fa-chevron-down" style="font-size: 0.8rem; color: #999;"></i>
                    </div>
                    <div class="timeline-content ${isEmpty ? 'empty' : ''}">
                        ${isEmpty ? (currentLang === 'zh' ? '暂无数据' : 'No data yet') : content}
                    </div>
                `;
                container.appendChild(node);
            });
        }
        
        function toggleTimelineItem(el) {
            const content = el.nextElementSibling;
            content.classList.toggle('active');
            const icon = el.querySelector('i');
            if (content.classList.contains('active')) {
                icon.className = 'fas fa-chevron-up';
            } else {
                icon.className = 'fas fa-chevron-down';
            }
        }

        // Init
        applyTranslations();
        updateLangSelect();
        renderTimeline(); // Render empty timeline immediately
        loadProfile();
        loadHistory();
        
        function switchLang(lang) {
            setLanguage(lang);
            renderTimeline(); // Re-render timeline titles
        }

        function updateLangSelect() {
            const select = document.getElementById('lang-select');
            if (select) select.value = currentLang;
        }

        async function loadHistory() {
            try {
                const res = await fetch(`${API_URL}/chat/history`, { headers });
                if (res.ok) {
                    const messages = await res.json();
                    messages.forEach(msg => {
                        addMessage(msg.content, msg.role);
                    });
                }
            } catch (e) {
                console.error("Failed to load history", e);
            }
        }
    </script>
</body>
</html>
